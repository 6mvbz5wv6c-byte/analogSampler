<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Local Listener Panel</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #111;
      color: #eee;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 8px 12px;
      background: #222;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #status {
      font-weight: bold;
    }
    #container {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
    }
    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
      color: #ccc;
      font-size: 13px;
    }
    button {
      background: #333;
      color: #eee;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 6px 10px;
      cursor: pointer;
    }
    button:hover { background: #444; }
    canvas {
      border: 1px solid #444;
      background: #000;
      width: 100%;
      height: 420px;
    }
  </style>
</head>
<body>
  <header>
    <span>Pigboy Geophone Monitor</span>
    <span id="status">Connecting...</span>
  </header>
  <div id="container">
    <div id="controls">
      <button id="follow">Jump to Live</button>
      <span>Drag to select a zoom window, Shift+Drag to pan. Buffer: 45 s.</span>
      <span id="view"></span>
    </div>
    <canvas id="scope" width="1200" height="420"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('scope');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const viewEl = document.getElementById('view');
    const followBtn = document.getElementById('follow');

    const BUFFER_SECONDS = 45;
    const DEFAULT_VIEW_SECONDS = 45;
    //const Y_SCALE = 500000; // constant vertical scale in ADC counts
    const Y_MIN = -8000000;
    const Y_MAX =  8000000;
    const AXIS_HEIGHT = 28;

    let tData = [];
    let geoData = [];
    let viewStart = 0;
    let viewSpan = DEFAULT_VIEW_SECONDS;
    let followLive = true;
    let isPanning = false;
    let panStartX = 0;
    let panStartView = 0;
    let isSelecting = false;
    let selectStartX = 0;
    let selectCurrentX = 0;
    let t0Abs = null;

    function clampView() {
      if (tData.length === 0) return;
      const minT = tData[0];
      const maxT = tData[tData.length - 1];
      const span = Math.min(viewSpan, BUFFER_SECONDS, Math.max(maxT - minT, DEFAULT_VIEW_SECONDS));
      viewSpan = Math.max(0.5, Math.min(span, BUFFER_SECONDS));

      const maxStart = maxT - viewSpan;
      viewStart = Math.max(minT, Math.min(viewStart, maxStart));
    }

    function formatRange() {
      const startSec = viewStart.toFixed(2);
      const endSec = (viewStart + viewSpan).toFixed(2);
      const spanSec = viewSpan.toFixed(2);
      viewEl.textContent = `View: ${startSec}s – ${endSec}s (Δ ${spanSec}s)`;
    }

    function biasAndScale(values) {
      if (!values.length) return [];
      const mean = values.reduce((acc, v) => acc + v, 0) / values.length;
      return values.map((v) => v - mean);
    }

    function drawGrid(w, h) {
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 1;
      ctx.beginPath();
      const gridX = 100;
      const gridY = 80;
      for (let x = 0; x <= w; x += gridX) {
        ctx.moveTo(x + 0.5, 0);
        ctx.lineTo(x + 0.5, h - AXIS_HEIGHT);
      }
      for (let y = 0; y <= h - AXIS_HEIGHT; y += gridY) {
        ctx.moveTo(0, y + 0.5);
        ctx.lineTo(w, y + 0.5);
      }
      ctx.stroke();
    }

    function drawTrace() {
      const w = canvas.width;
      const h = canvas.height;
      const plotH = h - AXIS_HEIGHT;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);

      if (!tData.length) {
        formatRange();
        return;
      }

      clampView();
      formatRange();
      drawGrid(w, h);

      const yMid = plotH / 2;

      // Fixed mapping: Y_MIN → bottom, Y_MAX → top
      const yRange = Y_MAX - Y_MIN;
      const scale = plotH / yRange;   // pixels per count

      // Center baseline
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, yMid + 0.5);
      ctx.lineTo(w, yMid + 0.5);
      ctx.stroke();

      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 1.5;
      ctx.beginPath();

      let started = false;

      for (let i = 0; i < tData.length; i++) {
        const t = tData[i];
        if (t < viewStart || t > viewStart + viewSpan) continue;

        const xNorm = (t - viewStart) / viewSpan;
        const x = xNorm * w;

        let v = geoData[i];
        if (!Number.isFinite(v)) continue;

        // clamp to fixed range
        if (v < Y_MIN) v = Y_MIN;
        if (v > Y_MAX) v = Y_MAX;

        // map counts to pixels:
        //   v = Y_MAX -> y ≈ 0 (top)
        //   v = 0     -> y ≈ middle
        //   v = Y_MIN -> y ≈ plotH (bottom)
        const y = (Y_MAX - v) * scale;

        if (!started) {
          ctx.moveTo(x, y);
          started = true;
        } else {
          ctx.lineTo(x, y);
        }
      }

      if (started) {
        ctx.stroke();
      }

      if (isSelecting) {
        ctx.fillStyle = 'rgba(0, 128, 255, 0.2)';
        ctx.strokeStyle = 'rgba(0, 128, 255, 0.7)';
        const x0 = Math.min(selectStartX, selectCurrentX);
        const x1 = Math.max(selectStartX, selectCurrentX);
        ctx.fillRect(x0, 0, x1 - x0, plotH);
        ctx.strokeRect(x0 + 0.5, 0.5, x1 - x0, plotH - 1);
      }

      drawTimeAxis(plotH, w);
    }


    function drawTimeAxis(plotH, w) {
      if (tData.length === 0 || t0Abs === null) return;

      const absStart = t0Abs + viewStart;
      const absEnd = absStart + viewSpan;
      const avgTime = (absStart + absEnd) / 2;
      const ticks = 6;

      ctx.strokeStyle = '#555';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, plotH + 0.5);
      ctx.lineTo(w, plotH + 0.5);
      ctx.stroke();

      ctx.fillStyle = '#bbb';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      for (let i = 0; i < ticks; i++) {
        const frac = i / (ticks - 1);
        const x = frac * w;
        const tTick = absStart + frac * viewSpan;
        ctx.fillText(formatTimestamp(tTick), x, plotH + 6);
      }

      ctx.textAlign = 'right';
      ctx.fillText('Avg:', w - 56, plotH + 6);
      ctx.textAlign = 'left';
      ctx.fillText(formatTimestamp(avgTime), w - 52, plotH + 6);
    }

    function formatTimestamp(seconds) {
      const date = new Date(seconds * 1000);
      const timeString = date.toISOString().split('T')[1].replace('Z', '');
      return `${timeString}`;
    }

    function setLiveView() {
      if (!tData.length) return;
      const maxT = tData[tData.length - 1];
      viewSpan = Math.min(viewSpan, BUFFER_SECONDS);
      viewStart = Math.max(tData[0], maxT - viewSpan);
      followLive = true;
      drawTrace();
    }

    function handleNewData(t0, t, geo) {
      tData = t;
      //geoData = biasAndScale(geo);
      geoData = geo;
      t0Abs = t0;

      if (followLive) {
        viewSpan = Math.min(Math.max(viewSpan, DEFAULT_VIEW_SECONDS), BUFFER_SECONDS);
        const maxT = tData[tData.length - 1];
        viewStart = Math.max(tData[0], maxT - viewSpan);
      }
      drawTrace();
    }

    canvas.addEventListener('mousedown', (event) => {
      if (!tData.length) return;
      if (event.shiftKey) {
        isPanning = true;
        panStartX = event.clientX;
        panStartView = viewStart;
      } else {
        isSelecting = true;
        const rect = canvas.getBoundingClientRect();
        selectStartX = Math.min(Math.max(event.clientX - rect.left, 0), canvas.width);
        selectCurrentX = selectStartX;
      }
      followLive = false;
      drawTrace();
    });

    window.addEventListener('mousemove', (event) => {
      if (!tData.length) return;
      const rect = canvas.getBoundingClientRect();
      const x = Math.min(Math.max(event.clientX - rect.left, 0), canvas.width);

      if (isPanning) {
        const dx = event.clientX - panStartX;
        const deltaT = (dx / canvas.width) * viewSpan;
        viewStart = panStartView - deltaT;
        clampView();
        drawTrace();
      } else if (isSelecting) {
        selectCurrentX = x;
        drawTrace();
      }
    });

    window.addEventListener('mouseup', () => {
      if (isSelecting) {
        const x0 = Math.min(selectStartX, selectCurrentX);
        const x1 = Math.max(selectStartX, selectCurrentX);
        if (Math.abs(x1 - x0) > 4) {
          const tStart = viewStart + (x0 / canvas.width) * viewSpan;
          const tEnd = viewStart + (x1 / canvas.width) * viewSpan;
          viewStart = tStart;
          viewSpan = Math.max(0.1, tEnd - tStart);
          clampView();
        }
        isSelecting = false;
        drawTrace();
      }

      if (isPanning) {
        isPanning = false;
      }
    });

    followBtn.addEventListener('click', () => {
      viewSpan = Math.min(BUFFER_SECONDS, Math.max(viewSpan, DEFAULT_VIEW_SECONDS));
      setLiveView();
    });

    function connectWS() {
      const proto = (location.protocol === 'https:') ? 'wss://' : 'ws://';
      const wsUrl = proto + location.host + '/ws';
      const ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        statusEl.textContent = 'Connected';
        statusEl.style.color = '#0f0';
      };

      ws.onclose = () => {
        statusEl.textContent = 'Disconnected, retrying...';
        statusEl.style.color = '#f80';
        setTimeout(connectWS, 2000);
      };

      ws.onerror = () => {
        statusEl.textContent = 'Error';
        statusEl.style.color = '#f00';
      };

      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          handleNewData(msg.t0, msg.t, msg.geo);
        } catch (e) {
          console.error('Bad message', e);
        }
      };
    }

    connectWS();
    drawTrace();
  </script>
</body>
</html>
